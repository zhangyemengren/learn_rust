/// 借用检查器使用显式的生命周期注释来确定引用的有效时间。
/// 在生命周期未被省略的情况下，Rust 需要显式注释来确定引用的生命周期应该是什么。
/// 显式注释生命周期的语法使用撇号字符，如下所示：
/// foo<'a> // `foo` 有一个生命周期参数 `'a`
/// 与闭包类似，使用生命周期需要泛型。
/// 此外，此生命周期语法表明 foo 的生命周期不得超过 'a.类型的显式注释具有 &'a T 的形式，其中 'a 已经被介绍。
/// 在具有多个生命周期的情况下，语法类似：
/// foo<'a, 'b>
/// 在这种情况下，foo 的生命周期不能超过 'a 或 'b 的生命周期。
/// 有关使用中的显式生命周期注释，请参阅以下示例：

// `print_refs` 接受两个对 `i32` 的引用，它们具有不同的生命周期 `'a` 和 `'b`。
// 这两个生命周期必须至少与函数“print_refs”一样长。
fn print_refs<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("x is {} and y is {}", x, y);
}

// 一个不带参数的函数，但有一个生命周期参数“a”。
fn failed_borrow<'a>() {
    let _x  = 12;

    // ERROR: `_x` does not live long enough
    let y: &'a i32 = &_x;
    // 在函数内部使用生命周期 `'a` 作为显式类型标注将导致失败，因为 `&_x` 的
    // 生命周期比 `y` 的短。短生命周期不能强制转换成长生命周期。('a为 'static 和_x是函数的生命周期)
}

fn main() {
    // 创建下面要借用的变量。
    let (four, nine) = (4, 9);

    // 两个变量的借位 (`&`) 都会传递到函数中。
    print_refs(&four, &nine);
    // 任何借用的输入都必须比借用者的生命周期长。
    // 换句话说，“four”和“nine”的生命周期必须比“print_refs”的生命周期长。

    failed_borrow();
    // `failed_borrow` 未包含引用，因此不要求 `'a` 长于函数的生命周期，
    // 但 `'a` 寿命确实更长。因为该生命周期从未被约束，所以默认为 `'static`。
}