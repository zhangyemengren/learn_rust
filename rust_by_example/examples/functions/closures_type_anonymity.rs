/// 闭包简洁地捕获封闭范围中的变量。这有什么后果吗？
/// 确实如此。观察使用闭包作为函数参数为何必须需要泛型，因为它们是如何定义的：
/// `F` must be generic.
/// fn apply<F>(f: F) where
///     F: FnOnce() {
///     f();
/// }
/// 定义闭包时，编译器会隐式创建一个新的匿名结构来在内部存储捕获的变量，同时通过以下特征之一实现这种未知类型：
/// Fn、FnMut 或 FnOnce。该类型在调用之前被分配给变量存储。
/// 由于这种新类型是未知类型，因此函数中的任何使用都需要泛型。
/// 但是，无界类型参数 <T> 仍然是不明确的并且是不允许的。
/// 因此，受以下特征之一的限制：Fn、FnMut 或 FnOnce 足以指定其类型。

// `F` 必须实现 `Fn` 来实现不接受任何输入且不返回任何内容的闭包
// - 这正是 `print` 所需要的。
fn apply<F>(f: F)
where
    F: Fn(),
{
    f();
}

fn main() {
    let x = 7;

    // 将 `x` 捕获为匿名类型并为其实现 `Fn`。将其存储在`print`中。
    let print = || println!("{}", x);

    apply(print);
}
